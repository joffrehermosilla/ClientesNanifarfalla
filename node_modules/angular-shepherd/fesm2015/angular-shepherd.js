import { Injectable, ɵɵdefineInjectable } from '@angular/core';
import Shepherd from 'shepherd.js';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/dom.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Helper method to check if element is hidden, since we cannot use :visible without jQuery
 * @param {?} element The element to check for visibility
 * @return {?} true if element is hidden
 */
function elementIsHidden(element) {
    return element.offsetWidth === 0 && element.offsetHeight === 0;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/buttons.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Creates a button of the specified type, with the given classes and text
 *
 * @param {?} button
 * @return {?}
 */
function makeButton(button) {
    const { classes, disabled, label, secondary, type, text } = button;
    /** @type {?} */
    const builtInButtonTypes = ['back', 'cancel', 'next'];
    if (!type) {
        return button;
    }
    if (builtInButtonTypes.indexOf(type) === -1) {
        throw new Error(`'type' property must be one of 'back', 'cancel', or 'next'`);
    }
    return {
        action: this[type].bind(this),
        classes,
        disabled,
        label,
        secondary,
        text
    };
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/shepherd.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShepherdService {
    constructor() {
        this.confirmCancel = false;
        this.confirmCancelMessage = null;
        this.defaultStepOptions = {};
        this.errorTitle = null;
        this.isActive = false;
        this.messageForUser = null;
        this.modal = false;
        this.requiredElements = [];
        this.steps = [];
        this.tourName = undefined;
        this.tourObject = null;
    }
    /**
     * Get the tour object and call back
     * @return {?}
     */
    back() {
        this.tourObject.back();
    }
    /**
     * Cancel the tour
     * @return {?}
     */
    cancel() {
        this.tourObject.cancel();
    }
    /**
     * Complete the tour
     * @return {?}
     */
    complete() {
        this.tourObject.complete();
    }
    /**
     * Hides the current step
     * @return {?}
     */
    hide() {
        this.tourObject.hide();
    }
    /**
     * Advance the tour to the next step
     * @return {?}
     */
    next() {
        this.tourObject.next();
    }
    /**
     * Show a specific step, by passing its id
     * @param {?} id The id of the step you want to show
     * @return {?}
     */
    show(id) {
        this.tourObject.show(id);
    }
    /**
     * Start the tour
     * @return {?}
     */
    start() {
        this.isActive = true;
        this.tourObject.start();
    }
    /**
     * This function is called when a tour is completed or cancelled to initiate cleanup.
     * @param {?} completeOrCancel 'complete' or 'cancel'
     * @return {?}
     */
    onTourFinish(completeOrCancel) {
        this.isActive = false;
    }
    /**
     * Take a set of steps and create a tour object based on the current configuration
     * @param {?} steps An array of steps
     * @return {?}
     */
    addSteps(steps) {
        this._initialize();
        /** @type {?} */
        const tour = this.tourObject;
        // Return nothing if there are no steps
        if (!steps || !Array.isArray(steps) || steps.length === 0) {
            return;
        }
        if (!this.requiredElementsPresent()) {
            tour.addStep({
                buttons: [{
                        text: 'Exit',
                        action: tour.cancel
                    }],
                id: 'error',
                title: this.errorTitle,
                text: [this.messageForUser]
            });
            return;
        }
        steps.forEach((/**
         * @param {?} step
         * @return {?}
         */
        (step) => {
            if (step.buttons) {
                step.buttons = step.buttons.map(makeButton.bind(this), this);
            }
            tour.addStep(step);
        }));
    }
    /**
     * Observes the array of requiredElements, which are the elements that must be present at the start of the tour,
     * and determines if they exist, and are visible, if either is false, it will stop the tour from executing.
     * @private
     * @return {?}
     */
    requiredElementsPresent() {
        /** @type {?} */
        let allElementsPresent = true;
        /* istanbul ignore next: also can't test this due to things attached to root blowing up tests */
        this.requiredElements.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            /** @type {?} */
            const selectedElement = document.querySelector(element.selector);
            if (allElementsPresent && (!selectedElement || elementIsHidden(selectedElement))) {
                allElementsPresent = false;
                this.errorTitle = element.title;
                this.messageForUser = element.message;
            }
        }));
        return allElementsPresent;
    }
    /**
     * Initializes the tour, creates a new Shepherd.Tour. sets options, and binds events
     * @private
     * @return {?}
     */
    _initialize() {
        /** @type {?} */
        const tourObject = new Shepherd.Tour({
            confirmCancel: this.confirmCancel,
            confirmCancelMessage: this.confirmCancelMessage,
            defaultStepOptions: this.defaultStepOptions,
            tourName: this.tourName,
            useModalOverlay: this.modal
        });
        tourObject.on('complete', this.onTourFinish.bind(this, 'complete'));
        tourObject.on('cancel', this.onTourFinish.bind(this, 'cancel'));
        this.tourObject = tourObject;
    }
}
ShepherdService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ShepherdService.ctorParameters = () => [];
/** @nocollapse */ ShepherdService.ɵprov = ɵɵdefineInjectable({ factory: function ShepherdService_Factory() { return new ShepherdService(); }, token: ShepherdService, providedIn: "root" });
if (false) {
    /** @type {?} */
    ShepherdService.prototype.confirmCancel;
    /** @type {?} */
    ShepherdService.prototype.confirmCancelMessage;
    /** @type {?} */
    ShepherdService.prototype.defaultStepOptions;
    /** @type {?} */
    ShepherdService.prototype.errorTitle;
    /** @type {?} */
    ShepherdService.prototype.isActive;
    /** @type {?} */
    ShepherdService.prototype.messageForUser;
    /** @type {?} */
    ShepherdService.prototype.modal;
    /** @type {?} */
    ShepherdService.prototype.requiredElements;
    /** @type {?} */
    ShepherdService.prototype.steps;
    /** @type {?} */
    ShepherdService.prototype.tourName;
    /** @type {?} */
    ShepherdService.prototype.tourObject;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: angular-shepherd.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ShepherdService };
//# sourceMappingURL=angular-shepherd.js.map
