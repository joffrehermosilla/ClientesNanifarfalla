{"version":3,"sources":["../../../projects/shepherd/src/lib/utils/buttons.ts","../../../projects/shepherd/src/lib/shepherd.service.ts","../../../projects/shepherd/src/lib/utils/dom.ts"],"names":["makeButton","button","classes","disabled","label","secondary","type","text","indexOf","Error","action","this","bind","ShepherdService","confirmCancel","confirmCancelMessage","defaultStepOptions","errorTitle","isActive","messageForUser","modal","requiredElements","steps","tourName","undefined","tourObject","prototype","back","cancel","complete","hide","next","show","id","start","onTourFinish","completeOrCancel","addSteps","_this","_initialize","tour","Array","isArray","length","requiredElementsPresent","forEach","step","buttons","map","addStep","title","allElementsPresent","element","selectedElement","document","querySelector","selector","offsetWidth","offsetHeight","elementIsHidden","message","Shepherd","Tour","useModalOverlay","on","Injectable","args","providedIn"],"mappings":"oVAQgBA,EAAWC,GACjB,IAAAC,EAAoDD,EAAMC,QAAjDC,EAA2CF,EAAME,SAAvCC,EAAiCH,EAAMG,MAAhCC,EAA0BJ,EAAMI,UAArBC,EAAeL,EAAMK,KAAfC,EAASN,EAAMM,KAGlE,IAAKD,EACH,OAAOL,EAGT,IAA0C,IANf,CAAC,OAAQ,SAAU,QAMvBO,QAAQF,GAC7B,MAAM,IAAIG,MAAM,8DAGlB,MAAO,CACLC,OAAQC,KAAKL,GAAMM,KAAKD,MACxBT,QAAOA,EACPC,SAAQA,EACRC,MAAKA,EACLC,UAASA,EACTE,KAAIA,uFCLN,SAAAM,IAZAF,KAAAG,eAAgB,EAChBH,KAAAI,qBAA+B,KAC/BJ,KAAAK,mBAA6B,GAC7BL,KAAAM,WAAa,KACbN,KAAAO,UAAW,EACXP,KAAAQ,eAAyB,KACzBR,KAAAS,OAAQ,EACRT,KAAAU,iBAAmB,GACnBV,KAAAW,MAAQ,GACRX,KAAAY,cAAWC,EACXb,KAAAc,WAA4B,YAQ5BZ,EAAAa,UAAAC,KAAA,WACEhB,KAAKc,WAAWE,QAMlBd,EAAAa,UAAAE,OAAA,WACEjB,KAAKc,WAAWG,UAMlBf,EAAAa,UAAAG,SAAA,WACElB,KAAKc,WAAWI,YAMlBhB,EAAAa,UAAAI,KAAA,WACEnB,KAAKc,WAAWK,QAMlBjB,EAAAa,UAAAK,KAAA,WACEpB,KAAKc,WAAWM,QAOlBlB,EAAAa,UAAAM,KAAA,SAAKC,GACHtB,KAAKc,WAAWO,KAAKC,IAMvBpB,EAAAa,UAAAQ,MAAA,WACEvB,KAAKO,UAAW,EAChBP,KAAKc,WAAWS,SAOlBrB,EAAAa,UAAAS,aAAA,SAAaC,GACXzB,KAAKO,UAAW,GAOlBL,EAAAa,UAAAW,SAAA,SAASf,GAAT,IAAAgB,EAAA3B,KACEA,KAAK4B,kBACCC,EAAO7B,KAAKc,WAGbH,GAAUmB,MAAMC,QAAQpB,IAA2B,IAAjBA,EAAMqB,SAIxChC,KAAKiC,0BAaVtB,EAAMuB,SAAO,SAAEC,GACTA,EAAKC,UACPD,EAAKC,QAAUD,EAAKC,QAAQC,IAAIhD,EAAWY,KAAK0B,GAAOA,IAGzDE,EAAKS,QAAQH,MAjBbN,EAAKS,QAAQ,CACXF,QAAS,CAAC,CACRxC,KAAM,OACNG,OAAQ8B,EAAKZ,SAEfK,GAAI,QACJiB,MAAOvC,KAAKM,WACZV,KAAM,CAACI,KAAKQ,oBAkBVN,EAAAa,UAAAkB,wBAAA,WAAA,IAAAN,EAAA3B,KACFwC,GAAqB,EAazB,OAVAxC,KAAKU,iBAAiBwB,SAAO,SAAEO,OACvBC,EAAkBC,SAASC,cAAcH,EAAQI,WAEnDL,GAAwBE,aC5HFD,GAC9B,OAA+B,IAAxBA,EAAQK,aAA8C,IAAzBL,EAAQM,aD2HOC,CAAgBN,KAC7DF,GAAqB,EACrBb,EAAKrB,WAAamC,EAAQF,MAC1BZ,EAAKnB,eAAiBiC,EAAQQ,YAI3BT,GAMDtC,EAAAa,UAAAa,YAAA,eACAd,EAAa,IAAIoC,EAASC,KAAK,CACnChD,cAAeH,KAAKG,cACpBC,qBAAsBJ,KAAKI,qBAC3BC,mBAAoBL,KAAKK,mBACzBO,SAAUZ,KAAKY,SACfwC,gBAAiBpD,KAAKS,QAGxBK,EAAWuC,GAAG,WAAYrD,KAAKwB,aAAavB,KAAKD,KAAM,aACvDc,EAAWuC,GAAG,SAAUrD,KAAKwB,aAAavB,KAAKD,KAAM,WAErDA,KAAKc,WAAaA,4BArJrBwC,EAAAA,WAAUC,KAAA,CAAC,CACVC,WAAY","sourcesContent":["/**\n * Creates a button of the specified type, with the given classes and text\n *\n * @param button.type The type of button cancel, back, or next\n * @param button.classes Classes to apply to the button\n * @param button.text The text for the button\n * @param button.action The action to call\n */\nexport function makeButton(button) {\n  const { classes, disabled, label, secondary, type, text } = button;\n  const builtInButtonTypes = ['back', 'cancel', 'next'];\n\n  if (!type) {\n    return button;\n  }\n\n  if (builtInButtonTypes.indexOf(type) === -1) {\n    throw new Error(`'type' property must be one of 'back', 'cancel', or 'next'`);\n  }\n\n  return {\n    action: this[type].bind(this),\n    classes,\n    disabled,\n    label,\n    secondary,\n    text\n  };\n}\n","import { Injectable } from '@angular/core';\nimport Shepherd from 'shepherd.js';\nimport { elementIsHidden } from './utils/dom';\nimport { makeButton } from './utils/buttons';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ShepherdService {\n  confirmCancel = false;\n  confirmCancelMessage: string = null;\n  defaultStepOptions: object = {};\n  errorTitle = null;\n  isActive = false;\n  messageForUser: string = null;\n  modal = false;\n  requiredElements = [];\n  steps = [];\n  tourName = undefined;\n  tourObject: Shepherd.Tour = null;\n\n  constructor() {\n  }\n\n  /**\n   * Get the tour object and call back\n   */\n  back() {\n    this.tourObject.back();\n  }\n\n  /**\n   * Cancel the tour\n   */\n  cancel() {\n    this.tourObject.cancel();\n  }\n\n  /**\n   * Complete the tour\n   */\n  complete() {\n    this.tourObject.complete();\n  }\n\n  /**\n   * Hides the current step\n   */\n  hide() {\n    this.tourObject.hide();\n  }\n\n  /**\n   * Advance the tour to the next step\n   */\n  next() {\n    this.tourObject.next();\n  }\n\n  /**\n   * Show a specific step, by passing its id\n   * @param id The id of the step you want to show\n   */\n  show(id) {\n    this.tourObject.show(id);\n  }\n\n  /**\n   * Start the tour\n   */\n  start() {\n    this.isActive = true;\n    this.tourObject.start();\n  }\n\n  /**\n   * This function is called when a tour is completed or cancelled to initiate cleanup.\n   * @param completeOrCancel 'complete' or 'cancel'\n   */\n  onTourFinish(completeOrCancel: string) {\n    this.isActive = false;\n  }\n\n  /**\n   * Take a set of steps and create a tour object based on the current configuration\n   * @param steps An array of steps\n   */\n  addSteps(steps: Array<any>) {\n    this._initialize();\n    const tour = this.tourObject;\n\n    // Return nothing if there are no steps\n    if (!steps || !Array.isArray(steps) || steps.length === 0) {\n      return;\n    }\n\n    if (!this.requiredElementsPresent()) {\n      tour.addStep({\n        buttons: [{\n          text: 'Exit',\n          action: tour.cancel\n        }],\n        id: 'error',\n        title: this.errorTitle,\n        text: [this.messageForUser]\n      });\n      return;\n    }\n\n    steps.forEach((step) => {\n      if (step.buttons) {\n        step.buttons = step.buttons.map(makeButton.bind(this), this);\n      }\n\n      tour.addStep(step);\n    });\n  }\n\n  /**\n   * Observes the array of requiredElements, which are the elements that must be present at the start of the tour,\n   * and determines if they exist, and are visible, if either is false, it will stop the tour from executing.\n   */\n  private requiredElementsPresent() {\n    let allElementsPresent = true;\n\n    /* istanbul ignore next: also can't test this due to things attached to root blowing up tests */\n    this.requiredElements.forEach((element) => {\n      const selectedElement = document.querySelector(element.selector);\n\n      if (allElementsPresent && (!selectedElement || elementIsHidden(selectedElement))) {\n        allElementsPresent = false;\n        this.errorTitle = element.title;\n        this.messageForUser = element.message;\n      }\n    });\n\n    return allElementsPresent;\n  }\n\n  /**\n   * Initializes the tour, creates a new Shepherd.Tour. sets options, and binds events\n   */\n  private _initialize() {\n    const tourObject = new Shepherd.Tour({\n      confirmCancel: this.confirmCancel,\n      confirmCancelMessage: this.confirmCancelMessage,\n      defaultStepOptions: this.defaultStepOptions,\n      tourName: this.tourName,\n      useModalOverlay: this.modal\n    });\n\n    tourObject.on('complete', this.onTourFinish.bind(this, 'complete'));\n    tourObject.on('cancel', this.onTourFinish.bind(this, 'cancel'));\n\n    this.tourObject = tourObject;\n  }\n}\n","/**\n * Helper method to check if element is hidden, since we cannot use :visible without jQuery\n * @param element The element to check for visibility\n * @returns true if element is hidden\n */\nexport function elementIsHidden(element: HTMLElement): boolean {\n  return element.offsetWidth === 0 && element.offsetHeight === 0;\n}\n"]}